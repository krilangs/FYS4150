\documentclass[12pt,a4paper,english]{article}
\usepackage{times}
\usepackage[utf8]{inputenc}
\usepackage{babel,textcomp}
\usepackage{mathpazo}
\usepackage{mathtools}
\usepackage{amsmath,amssymb}
\usepackage{ dsfont }
\usepackage{listings}
\usepackage{graphicx}
\usepackage{float}
\usepackage{subfig} 
\usepackage[colorlinks]{hyperref}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{textcomp}
\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{backgroundcolor=\color{lbcolor},tabsize=4,rulecolor=,language=python,basicstyle=\scriptsize,upquote=true,aboveskip={1.5\baselineskip},columns=fixed,numbers=left,showstringspaces=false,extendedchars=true,breaklines=true,
prebreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},frame=single,showtabs=false,showspaces=false,showstringspaces=false,identifierstyle=\ttfamily,keywordstyle=\color[rgb]{0,0,1},commentstyle=\color[rgb]{0.133,0.545,0.133},stringstyle=\color[rgb]{0.627,0.126,0.941},literate={å}{{\r a}}1 {Å}{{\r A}}1 {ø}{{\o}}1}

% Use for references
%\usepackage[sort&compress,square,comma,numbers]{natbib}
%\DeclareRobustCommand{\citeext}[1]{\citeauthor{#1}~\cite{#1}}

% Fix spacing in tables and figures
%\usepackage[belowskip=-8pt,aboveskip=5pt]{caption}
%\setlength{\intextsep}{10pt plus 2pt minus 2pt}

% Change the page layout
%\usepackage[showframe]{geometry}
\usepackage{layout}
\setlength{\hoffset}{-0.5in}  % Length left
%\setlength{\voffset}{-1.1in}  % Length on top
\setlength{\textwidth}{470pt}  % Width /597pt
%\setlength{\textheight}{720pt}  % Height /845pt
%\setlength{\footskip}{25pt}

\newcommand{\VEV}[1]{\langle#1\rangle}
\title{FYS4150 - Project 3}
\date{}
\author{ Kristoffer Langstad\\ \textit{krilangs@uio.no}}

\begin{document}%\layout
\maketitle
\begin{abstract}
In this project we want to solve an integral of the quantum mechanical expectation value of the correlation energy between two electrons which repel each other via the classical Coulomb interaction. For this integral we neglect the normalization factor. This integral can be solved in closed form and has an answer ($5\pi^2/16^2$) that we will try to get from our numerical methods. We will use different numerical integration methods to see the difference in both the methods, and the difference in brute force calculation versus more thought out methods. Then we will compare the convergence to the answer of the methods as of how many mesh points are needed to get at the level of third leading digit, and the CPU time used for the different methods to reach this answer. First we use a brute force Gaussian-Legendre quadrature integration to solve the integral. Then we improve the method by using Gaussian-Laguerre and change to spherical coordinates. The last three methods are variants of Monte Carlo integration; where we first use brute force with a uniform distribution, then improve by using importance sampling with an exponential distribution and spherical coordinates and lastly we will use parallelization of Monte Carlo. The brute force Gaussian-Legendre method is as we would expect quite slow, and we reach the analytic answer at third leading digit around 15 mesh points with CPU time 1 102 ms. For the improved Gaussian-Laguerre method we reach the third leading digit around 10 mesh points with CPU time 4 139 ms. So the improved method is slower, but seems to be more accurate and reaches the goal earlier. For the Monte Carlo we reach the third leading digit around $10^5$ mesh points with CPU time 55 835 $\mu$s. For the improved Monte Carlo we reach the goal after around $10^4$ mesh points with CPU time 9 294 $\mu$s. So we can conclude that the Monte Carlo is the better method when we reach high number of mesh points. There the Monte Carlo has similar accuracy as the Gaussian quadrature methods, while being much faster. When we parallelize the Monte Carlo with compiler flag \textbf{-O3} in C++, we get the same results as for the improved only with faster CPU time 4 823 $\mu$s.
\end{abstract}

\section{Introduction}
The efficiency of numerical integration methods have a great importance to us when solving physical problems. Today, there are many numerical integration methods that can be used. So to find the optimal method to solve our problem is important. That is why we will study different numerical methods to see the importance of optimization of the methods versus brute force integrations.

In this project we solve a six-dimensional integral, which is used to determine the ground state correlation energy between two electrons in a helium atom. For this project we will first look at different versions of Gaussian quadrature before we move over to different Monte Carlo integration methods. The Gaussian quadrature integration methods are mostly used in low-dimensional cases, while Monte Carlo are mostly used in multidimensional cases.

In the methods section we look at the theory of the physical problem and the different numerical algorithms we are using. For the integral we are solving in closed form, the quantum mechanical expectation value of the correlation energy between two electrons without a normalization factor, we compare our numerical results with a known solution. We will then compare the results we get between the different numerical integration methods to see the difference between brute force methods and more thought out methods. The methods we are using are brute force Gaussian-Legendre Quadrature, Gaussian-Laguerre quadrature in spherical coordinates, brute force Monte Carlo, improved Monte Carlo by use of importance sampling and parallelized Monte Carlo. In the results we present and compare our results of the numerical integration methods and discuss the methods used. Then in the conclusion section we come up with a conclusion to the project, and which method is the best.

\section{Method}
\subsection{Integration problem}
We first look at a six-dimensional integral that determines the ground state correlation energy between two electrons in a helium atom. Then we assume that the wave function for each of the electrons can be modeled like a single-particle wave function of an electron in the hydrogen atom. The single particle wave function for an electron $i$ in the 1st state for a dimensionless variable $\textbf{r}_i=x_i\textbf{e}_x+y_i\textbf{e}_y+z_i\textbf{e}_z$ and $r_i=\sqrt{x_i^2+y_i^2+z_i^2}$, can be expressed as 
\begin{equation}
\label{eq:wave_func}
\psi_{1s}(\textbf{r}_i)=e^{-\alpha r_i}.
\end{equation}
Then we fix the constant $\alpha=2$, which represents the charge of the He-atom (Z=2). 

The wave function for two electrons can then be written as the product of two single-particle ($1s$) wave functions as
\begin{equation}
\label{eq:wave_2}
\Psi(\textbf{r}_1, \textbf{r}_2)=e^{-\alpha(r_1+r_2)}.
\end{equation}
This two interacting electrons problem in the helium atom has no analytical solution to the Schrödinger equation. 

So the integral we need to solve is the quantum mechanical expectation value of the correlation energy between two electrons which repel each other via the classical Coulomb interaction:
\begin{equation}
\langle\frac{1}{|\textbf{r}_1-\textbf{r}_2|}\rangle=\int_{-\infty}^{\infty}e^{-2\alpha(r_1+r_2)}\frac{1}{|\textbf{r}_1-\textbf{r}_2|}d\textbf{r}_1d\textbf{r}_2
\end{equation}
The wave function is not normalized, so there is a normalization factor that we neglect in this project. The above integral can be solved in closed form with answer $\frac{5\pi^2}{16^2}$, which is used to compare with later.

\subsection{Gaussian-Legendre quadrature}
\subsection{Gaussian-Laguerre quadrature}
\subsection{Monte Carlo integration}
\subsection{Improved Monte Carlo integration}
\subsection{Monte Carlo parallelized}
\section{Results}


\begin{table}[htbp]
	\centering
	%\hspace{-1cm}
	\begin{tabular}{ |c|c|c|c|c| }
		\hline \rule{0pt}{13pt}
		Mesh points (N) & Numerical & Analytical & Difference & CPU time [ms]\\
		\hline \rule{0pt}{13pt}
		5 & 0.308692 & 0.192766 & 0.115926 & 1 \\
		\hline \rule{0pt}{13pt}
		10 & 0.154052 & 0.192766 & 0.0387138 & 97 \\
		\hline \rule{0pt}{13pt}
		15 & 0.187130 & 0.192766 & 0.00563558 & 1102 \\
		\hline \rule{0pt}{13pt}
		20 & 0.180469 & 0.192766 & 0.0122967 & 5729 \\
		\hline \rule{0pt}{13pt}
		25 & 0.185593 & 0.192766 & 0.00717284 & 22936 \\
		\hline \rule{0pt}{13pt}
		30 & 0.185011 & 0.192766 & 0.00775459 & 71586 \\
		\hline 
	\end{tabular}	
	\caption{Table for brute force Gaussian-Legendre quadrature integration results with integration limit $\lambda=1.5$. The numerical results are what we get for the given number of mesh points. The differences are means of a number of sets of absolute differences between the numerical and analytical results. The absolute difference decreases and the CPU time, in milliseconds, increases as the mesh points increases. We see that the difference does not decrease all the time as it converges towards zero, but seem to go up and down as the mesh points increases.}
	\label{tab:Gauss_Leg}
\end{table}

\begin{table}[htbp]
	\centering
	%\hspace{-1cm}
	\begin{tabular}{ |c|c|c|c|c| }
		\hline \rule{0pt}{13pt}
		Mesh points (N) & Numerical & Analytical & Difference & CPU time [ms]\\
		\hline \rule{0pt}{13pt}
		5 & 0.174353 & 0.192766 & 0.0184125 & 6 \\
		\hline \rule{0pt}{13pt}
		10 & 0.186544 & 0.192766 & 0.00622209 & 309 \\
		\hline \rule{0pt}{13pt}
		15 & 0.189757 & 0.192766 & 0.00300848 & 4139 \\
		\hline \rule{0pt}{13pt}
		20 & 0.191066 & 0.192766 & 0.00169936 & 23450 \\
		\hline \rule{0pt}{13pt}
		25 & 0.191724 & 0.192766 & 0.00104137 & 96382 \\
		\hline \rule{0pt}{13pt}
		30 & 0.192099 & 0.192766 & 0.000666809 & 354909 \\
		\hline 
	\end{tabular}
	\caption{Table for Gaussian-Laguerre quadrature results for spherical coordinates. For this case we have a more stable and faster decrease in the absolute difference than in Table \ref{tab:Gauss_Leg}. So for the comparison between the numerical and analytical results goes, this improved Gaussian quadrature integration method with Laguerre polynomial and spherical coordinates is better than the brute force with Legendre polynomial. The CPU time, in milliseconds, on the other hand, is a lot higher in this case than for the brute force.}
	\label{tab:Gauss_Lag}
\end{table}

\begin{table}[htbp]
	\centering
	%\hspace{-1cm}
	\begin{tabular}{ |c|c|c|c|c|c| }
		\hline \rule{0pt}{13pt}
		Mesh points (N) & Numerical & Analytical & Difference & Variance & CPU time [$\mu$s]\\
		\hline \rule{0pt}{13pt}
		$10$ & 0.0520594 & 0.192766 & 0.140706 & $9.60859\cdot10^{-4}$ & 3 \\
		\hline \rule{0pt}{13pt}
		$10^2$ & 0.0858179 & 0.192766 & 0.106948 & $2.56645\cdot10^{-3}$ & 5 \\
		\hline \rule{0pt}{13pt}
		$10^3$ & 0.108695 & 0.192766 & 0.0840702 & $4.91805\cdot10^{-4}$ & 964 \\
		\hline \rule{0pt}{13pt}
		$10^4$ & 0.160121 & 0.192766 & 0.0326449 & $3.90958\cdot10^{-4}$ & 6283 \\
		\hline \rule{0pt}{13pt}
		$10^5$ & 0.196523 & 0.192766 & 0.00375685 & $1.15132\cdot10^{-4}$ & 55835 \\
		\hline \rule{0pt}{13pt}
		$10^6$ & 0.193233 & 0.192766 & 0.000467207 & $1.99508\cdot10^{-5}$ & 573519 \\
		\hline 
	\end{tabular}	
	\caption{Table for brute force Monte Carlo integration results with integration limit $\lambda=1.5$. For this method we see that for mesh points up to around $10^4$, the numerical results are worse than for the Gaussian quadrature methods. With higher mesh points than this, the numerical results become very good. The CPU time, in microseconds, for this brute force Monte Carlo, is much better than for the Gaussian quadratures. For around N=30 the CPU time were in seconds for Gaussian quadrature, but for this Monte Carlo method we use around half a second for N=$10^6$. The variance is low, and decreases a little as the mesh points increases.}
	\label{tab:MC_brute}
\end{table}

\begin{table}[htbp]
	\centering
	%\hspace{-1cm}
	\begin{tabular}{ |c|c|c|c|c|c| }
		\hline \rule{0pt}{13pt}
		Mesh points (N) & Numerical & Analytical & Error & Variance & CPU time [$\mu$s]\\
		\hline \rule{0pt}{13pt}
		$10$ & 0.365879 & 0.192766 & 0.173114 & $4.59202\cdot10^{-2}$ & 0 \\
		\hline \rule{0pt}{13pt}
		$10^2$ & 0.155251 & 0.192766 & 0.0375148 & $1.56870\cdot10^{-3}$ & 47 \\
		\hline \rule{0pt}{13pt}
		$10^3$ & 0.173329 & 0.192766 & 0.0194369 & $2.87435\cdot10^{-4}$ & 1258 \\
		\hline \rule{0pt}{13pt}
		$10^4$ & 0.188290 & 0.192766 & 0.00447596 & $9.22912\cdot10^{-5}$ & 9294 \\
		\hline \rule{0pt}{13pt}
		$10^5$ & 0.187134 & 0.192766 & 0.00563153 & $8.96394\cdot10^{-6}$ & 105771 \\
		\hline \rule{0pt}{13pt}
		$10^6$ & 0.191672 & 0.192766 & 0.00109395 & $9.26449\cdot10^{-7}$ & 994728 \\
		\hline 
	\end{tabular}	
	\caption{Table for improved Monte Carlo integration results for spherical coordinates. This improved Monte Carlo method gives a better absolute difference between the numerical and analytical results for lower number of mesh points than the brute force Monte Carlo in Table \ref{tab:MC_brute}. Fo higher mesh points, it seems like the brute force is a little more accurate. As in the Gaussian quadrature cases, the improved method with spherical coordinates seem to use longer CPU time than the brute forces. For the Monte Carlo methods, the time increase between the methods is not that high and are still in microseconds. The variance for the improved Monte Carlo is higher for for lower mesh points, but decreases more as the mesh points increases. For N=$10^{6}$ mesh points the variance in the improved method is much lower than for the brute force.}
	\label{tab:MC_improved}
\end{table}

\begin{table}[htbp]
	\centering
	%\hspace{-1cm}
	\begin{tabular}{ |c|c|c|c|c| }
		\hline \rule{0pt}{13pt}
		Compiler flags & -O1 & -O2 & -O3 & -Ofast \\
		\hline \rule{0pt}{13pt}
		CPU time [$\mu$s] & 597584 & 521989 & 439243 & 446278 \\
		\hline 
	\end{tabular}	
	\caption{Table for parallelized Monte Carlo integration results for 8 number of threads and $N=10^6$ number of mesh points. Comparing the CPU time for different C++ compiler flags. Here we see that -O3 seems to be the fastest in our case.}
	\label{tab:MC_opt_compile}
\end{table}

\begin{table}[htbp]
	\centering
	%\hspace{-1cm}
	\begin{tabular}{ |c|c|c|c|c|c| }
	\hline \rule{0pt}{13pt}
	Mesh points (N) & Numerical & Analytical & Error & Variance & CPU time [$\mu$s]\\
	\hline \rule{0pt}{13pt}
	$10$ & 0.365879 & 0.192766 & 0.173114 & $4.59202\cdot10^{-2}$ & 0 \\
	\hline \rule{0pt}{13pt}
	$10^2$ & 0.155251 & 0.192766 & 0.0375148 & $1.56870\cdot10^{-3}$ & 8 \\
	\hline \rule{0pt}{13pt}
	$10^3$ & 0.173329 & 0.192766 & 0.0194369 & $2.87435\cdot10^{-4}$ & 998 \\
	\hline \rule{0pt}{13pt}
	$10^4$ & 0.188290 & 0.192766 & 0.00447596 & $9.22912\cdot10^{-5}$ & 4823 \\
	\hline \rule{0pt}{13pt}
	$10^5$ & 0.187134 & 0.192766 & 0.00563153 & $8.96394\cdot10^{-6}$ & 42656 \\
	\hline \rule{0pt}{13pt}
	$10^6$ & 0.191672 & 0.192766 & 0.00109395 & $9.26449\cdot10^{-7}$ & 418861 \\
	\hline 
\end{tabular}	
	\caption{Table for parallelized Monte Carlo integration results for spherical coordinates and with 8 number of threads. This is run with the compiler flag \textbf{-O3} in C++, since this gave the best CPU times (as seen in Table \ref{tab:MC_opt_compile}). The results we get are equal to the ones in Table \ref{tab:MC_improved} for the improved Monte Carlo, except that in this case the CPU time, in microseconds, is much better. This is exactly what we wanted with the parallelization. For chosen higher number of threads than what we have chosen, the CPU time decreases but then the numerical results are get worse. For lower number of threads the numerical results are closer to the analytical, but has higher CPU time. So the chosen 8 number of threads is a compromise between the accuracy and CPU time.}
	\label{tab:MC_parallel}
\end{table}

\section{Conclusion}
\appendix
\section{Appendix}
\label{sect:appendix}
\end{document}
